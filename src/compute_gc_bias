#!/usr/bin/env python

"""
Compute the fragment rates for various GC lengths.
Version: %(scriptVersion)s
    
    usage:
     compute_gc_bias [options] reference.fa mappable.bed alignments.bam

    where the options are:
        -h,--help     : print usage and quit
        -d,--debug    : print debug information
        -t,--threads  : use these many threads [1]
        -s,--shift    : ignore these many bases at the edge of the fragments [0]
        -m,--minpos   : trust rates only if the number of positions with GC
                        value exceed this threshold [1000]
        -f,--fraction : subsample this fraction of positions to calculate the 
                        rates [0.01]
        -c,--chroms   : use this comma-separated list of chromosome in 
                        calculating the rates only [all]
        -v,--version  : print version and exit
        -q,--quality  : do not consider locations where the mean MQ is less
                        than this threshold [30]


   where the arguments are:
        reference.fa : the fasta file of reference sequence
        mappable.bed : the file in BED format that includes regions that are
                       mappable reads of lengths used in this run
        alignments.bam : the alignments of the reads in BAM format 

    Notes:
    1. Optionally the user can specify the number of positions to sample by
       specifying the -f option as an integer > 1.
    2. A script convert_gem_to_bed with this distribution can be used to 
       generate mappable.bed from the output of gem-mappability.
"""

from sys import argv, stderr, stdin, exit, stdout, path
from getopt import getopt, GetoptError
from time import time
from collections import Counter
from random import sample, randint
from bitarray import bitarray
from multiprocessing import Pool
from math import ceil
from array import array

import signal as sg
import pysam as ps
import numpy as np

from utils import *

__author__ = "Aakrosh Ratan"
__email__  = "ratan@virginia.edu"

# do we want the debug information to be printed?
Debug_flag = False

# number of threads to be used 
Num_threads = 1

# number of bases to be ignored from the edge of the fragments
Shift = 0

# fraction of positions to subsample
Fraction = 0.01

# Shared by all threads
Mqmap = {}
Seqmap = {}

def summarize_counter(counter):
    """Return the mean and std of the values in the Counter.
    """
    sum_of_numbers = sum(number*count for number,count in counter.items())
    count = sum(count for n,count in counter.items())
    mean = sum_of_numbers * 1.0 / count

    total_squares = sum(number*number*count for number,count in counter.items())
    mean_of_squares = total_squares / count
    variance = mean_of_squares - mean * mean
    std_dev = sqrt(variance)    
    return mean,std_dev

def calculate_inserts(filename):
    """Analyze numrequired fragments to infer information about the insert
sizes.
    """
    numrequired = 100000

    bamfile = ps.AlignmentFile(filename, 'rb')
    lengths = Counter()
    numanalyzed = 0

    for aln in bamfile:
        if random() < 0.01:
            if aln.is_duplicate or \
               aln.is_qcfail or \
               aln.is_secondary or \
               aln.is_supplementary or \
               aln.is_unmapped or \
               aln.mate_is_unmapped: continue

            if aln.is_proper_pair and aln.template_length > 0:
                lengths[aln.template_length] += 1
                numanalyzed += 1
            if numanalyzed == numrequired: break

    print >> stderr, "Sampled %d proper pairs to create a distribution"\
          % numanalyzed
    mean,std_dev = summarize_counter(lengths)
    return int(mean),std_dev

def calculate_coverage_stats(refname, bamname, chroms):
    """Analyze numrequired positions to infer information about coverage
    """
    coverage = Counter()

    global Num_threads
    inputs = []
    nums = 10000

    with open("%s.fai" % refname, 'r') as f:
        for line in f:
            chrom,length,_,_,_ = line.strip().split("\t")
            length = int(length)
            if chroms and chrom not in chroms: continue
            
            if (length-nums-1) < 0: continue
            start = randint(0, length-nums-1) 
            inputs.append((bamname, chrom, start, start + nums))
    
    original_sigint_handler = sg.signal(sg.SIGINT, sg.SIG_IGN)
    pool = Pool(processes = Num_threads)
    sg.signal(sg.SIGINT, original_sigint_handler)

    try:
        for _coverage in pool.imap_unordered(calculate_coverage,inputs):
            coverage += _coverage
    except KeyboardInterrupt:
        pool.terminate()
    else:
        pool.close()
    pool.join()
        
    mean,std_dev = summarize_counter(coverage)
    return int(mean),std_dev

def calculate_coverage(args):
    return _calculate_coverage(*args)

def _calculate_coverage(bamname, chrom, start, stop):
    coverage = Counter()

    bf = ps.AlignmentFile(bamname, 'rb')
    for pc in bf.pileup(chrom, start, stop):
        mq = np.mean([pr.alignment.mapping_quality for pr in pc.pileups])
        if mq < 30: continue
        coverage[pc.n] += 1
    bf.close()

    return coverage

def gen_reference_mq(refname, mapname, chroms):
    """ Generate a map of mappable location.
    """
    global Mqmap

    # read in the length of the contigs, and assign memory for them
    with open("%s.fai" % refname, 'r') as f:
        for line in f:
            chrom,length,_,_,_ = line.strip().split("\t")
            length = int(length)
            assert chrom not in Mqmap
            if chroms and chrom not in chroms: continue
            Mqmap[chrom] = bitarray([0]* length)

    # read in the mappability information marking the mappable bases
    with open(mapname, 'r') as f:
        for line in f:
            chrom,start,stop = line.strip().split("\t")
            if chroms and chrom not in chroms: continue
            chrom_map = Mqmap[chrom]
            chrom_map[int(start):int(stop)] = True

def gen_reference_seq(refname, chroms):
    global Seqmap
    ff = ps.FastaFile(refname)

    # read in the length of the contigs, and assign memory for them
    with open("%s.fai" % refname, 'r') as f:
        for line in f:
            chrom,_,_,_,_ = line.strip().split("\t")
            if chroms and chrom not in chroms: continue
            Seqmap[chrom] = ff.fetch(chrom).upper()

    ff.close()

def main(refname, mapname, bamname, min_num_pos, chroms, minq):
    global Num_threads, Fraction, Shift

    # get the average insert length
    av_insert,std_insert = calculate_inserts(bamname)
    update("Mean and std of insert lengths: %d,%.2f" % (av_insert,std_insert))

    # read the mappability information for the reference
    gen_reference_mq(refname, mapname, chroms)
    update("Generated the mappability hash")
 
    # read the sequence from the reference
    gen_reference_seq(refname, chroms)
    update("Generated the sequence hash")

    # calculate coverage cutoffs for locations I am going to consider
    meancov,stdcov=calculate_coverage_stats(refname, bamname, chroms)
    mincutoff = max(meancov - 3*stdcov, 0)
    maxcutoff = meancov + 3*stdcov
    update("Coverage cutoff: %d,%d" % (mincutoff,maxcutoff))

    # calculate the sum of all chromosome lengths which will be needed in case
    # of subsampling
    if Fraction > 1.0:
        dblen = 0
        with open("%s.fai" % refname, 'r') as f:
            for line in f:
                chrom,length,_,_,_ = line.strip().split("\t")
                if chroms and chrom not in chroms: continue
                dblen += int(length)

    rates = np.zeros(shape = (av_insert+1, 2), dtype = np.int) 
    inputs = []
 
    with open("%s.fai" % refname, 'r') as f:
        for line in f:
            chrom,length,_,_,_ = line.strip().split("\t")
            length = int(length)
            if chroms and chrom not in chroms: continue
            if chrom not in Mqmap : continue
            
            num_select = None
            if Fraction < 1.0:
                num_select = int(length * Fraction) 
            elif Fraction > 1.0:
                num_select = int(length * Fraction / dblen)     
   
            partsize = int(ceil(length / Num_threads))
            for i in xrange(0, length, partsize):
                inputs.append((chrom,i,min(i+partsize,length),bamname,
                               mincutoff,maxcutoff,av_insert,
                               int(num_select*1.0/Num_threads), minq))
       
    original_sigint_handler = sg.signal(sg.SIGINT, sg.SIG_IGN)
    pool = Pool(processes = Num_threads)
    sg.signal(sg.SIGINT, original_sigint_handler)
    update("Ready to start using the pool")     

    try:
        for _rates in pool.imap_unordered(process_region,inputs):
            rates += _rates
    except KeyboardInterrupt:
        pool.terminate()
    else:
        pool.close()
    pool.join()
    update("Calculated the fragment rates from the subsample")

    # calculate the global rate
    frags = 0
    numpos = 0
    for i in xrange(0, av_insert+1):
        numpos += rates[i][0]
        frags += rates[i][1]
    meanrate = frags * 1.0 / numpos

    # are there any GC values for which we are unable to calculate rates?
    left = []
    for i in xrange(0, av_insert+1):
        if rates[i][0] == 0 or rates[i][0] < min_num_pos:
            rates[i][0] = 0
            rates[i][1] = 0
            left.append(i)
    update("Another attempt to calculate rates at %d GC values" % len(left))
    left = set(left)
    inputs = []

    # final attempt to calculate the remaining rates
    with open("%s.fai" % refname, 'r') as f:
        for line in f:
            chrom,length,_,_,_ = line.strip().split("\t")
            length = int(length)
            if chroms and chrom not in chroms: continue
            if chrom not in Mqmap : continue
            
            partsize = int(ceil(length / Num_threads))
            for i in xrange(0, length, partsize):
                inputs.append((chrom,i,min(i+partsize,length), bamname, 
                               mincutoff,maxcutoff,av_insert,minq,left))

    original_sigint_handler = sg.signal(sg.SIGINT, sg.SIG_IGN) 
    pool = Pool(processes = Num_threads)
    sg.signal(sg.SIGINT, original_sigint_handler)

    try:
        for _rates in pool.imap_unordered(process_region_left,inputs):
            rates += _rates
    except KeyboardInterrupt:
        pool.terminate()
    else:
        pool.close()
    pool.join()
    update("Calculated the fragment rates")

    for i in xrange(0, av_insert+1):
        if rates[i][0] == 0: continue
        if rates[i][0] < min_num_pos: continue

        rate = rates[i][1]*1.0/rates[i][0]
        if rate == 0.0: continue    
        
        print tabout(i,rates[i][0], rates[i][1],meanrate/rate)
    print tabout(av_insert,minq,"-","-")     
  
def process_region(args):
    return _process_region(*args)

def process_region_left(args):
    return _process_region_left(*args)

def _process_region(chrom,start,end,bamname,mincutoff,
                    maxcutoff, av_insert, numselect, minq):
    global Shift, Mqmap, Seqmap

    bf = ps.AlignmentFile(bamname, 'rb')
    chrommq = Mqmap[chrom]
    chromseq = Seqmap[chrom]
    rates = np.zeros(shape = (av_insert+1, 2), dtype = np.int) 

    smpls = sample(range(start,end),min(numselect,end-start))
    locs = [x for x in smpls if chrommq[x]]
    locs = set(locs)    

    for pc in bf.pileup(chrom, start, end, truncate = True):
        if pc.reference_pos not in locs: continue
        if (pc.n > maxcutoff) or (pc.n < mincutoff): continue       

        counter = Counter(chromseq[pc.reference_pos+Shift:pc.reference_pos+av_insert-Shift])
        gc = counter['G'] + counter['C']

        frags = 0
        mqsum = 0
        for pr in pc.pileups:
            if pr.is_head and pr.alignment.is_reverse == False:
                frags += 1 
                mqsum += pr.alignment.mapping_quality
        if frags != 0 and (mqsum*1.0/frags) < minq: continue

        rates[gc][0] += 1
        rates[gc][1] += frags

    bf.close()
    return rates

def _process_region_left(chrom, start, end, bamname, mincutoff,
                         maxcutoff, av_insert, minq, left):
    global Shift, Mqmap, Seqmap

    bf = ps.AlignmentFile(bamname, 'rb')
    rates = np.zeros(shape = (av_insert+1, 2), dtype = np.int) 
    chrommq = Mqmap[chrom]
    chromseq = Seqmap[chrom]
    locs  = np.zeros((end - start), dtype = np.int)

    counter = Counter(chromseq[start+Shift:start+av_insert-Shift])
    gc = counter['G'] + counter['C'] 
    pos = start + 1
    numpos = 0
    totlen = len(chromseq)

    while pos < end:
        if (pos+Shift) < totlen:
            counter[chromseq[pos+Shift-1]] -= 1
        if (pos+av_insert-Shift) < totlen:
            counter[chromseq[pos+av_insert-Shift]] += 1
        gc = counter['G'] + counter['C']
        if gc in left :
            locs[numpos] = pos
            numpos += 1
        pos += 1

    locs = set(locs[0:numpos])

    for pc in bf.pileup(chrom, start, end, truncate = True):
        if pc.reference_pos not in locs: continue
        if (pc.n > maxcutoff) or (pc.n < mincutoff): continue       

        counter = Counter(chromseq[pc.reference_pos+Shift:pc.reference_pos+av_insert-Shift])
        gc = counter['G'] + counter['C']

        frags = 0
        mqsum = 0
        for pr in pc.pileups:
            if pr.is_head and pr.alignment.is_reverse == False:
                frags += 1 
                mqsum += pr.alignment.mapping_quality
        if frags != 0 and (mqsum*1.0/frags) < minq: continue

        rates[gc][0] += 1
        rates[gc][1] += frags

    bf.close()
    return rates

if __name__ == "__main__":
    with open(path[0]+'/VERSION',"r") as version_file:
        version = version_file.read().strip()

    try:
        opts, args = getopt(argv[1:], "hdt:s:m:f:c:vq:",
                     ["help","debug","threads=","shift=","minpos=", 
                      "fraction=", "chroms=", "version", "quality="])
    except GetoptError, err:
        print str(err)
        print >> stderr, __doc__ % {'scriptVersion':version}
        exit(2) 

    min_num_pos = 1000
    chroms = None
    printversion = False
    min_quality = 30

    for o, a in opts:
        if o in ("-h", "--help"):
            print >> stderr, __doc__ % {'scriptVersion':version}
            exit()
        elif o in ("-d", "--debug"):
            debug_flag = True
        elif o in ("-t", "--threads"):
            Num_threads = int(a)
        elif o in ("-s", "--shift"):
            Shift = int(a)
        elif o in ("-m", "--minpos"):
            min_num_pos = int(a)
        elif o in ("-f" ,"--fraction"):
            Fraction = float(a)
        elif o in ("-c", "--chroms"):
            chroms = a.split(",")
            chroms = set(chroms)
        elif o in ("-v", "--version"):
            printversion = True
        elif o in ("-q", "--quality"):  
            min_quality = int(a)
        else:
            assert False, "unhandled option"

    if printversion:
        print >> stderr, "Program: compute_gc_bias"
        print >> stderr, "Version: %s" % version
        print >> stderr, "Contact: Aakrosh Ratan (ratan@virginia.edu)"
        exit(0)

    if len(args) != 3:
        print >> stderr, __doc__ % {'scriptVersion':version}
        exit(3)

    main(args[0], args[1], args[2], min_num_pos, chroms, min_quality)
